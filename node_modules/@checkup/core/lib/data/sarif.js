"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sarifBuilder = exports.fromTaskErrors = exports.NO_RESULTS_FOUND = void 0;
exports.NO_RESULTS_FOUND = 'No results found';
/**
 * Builds SARIF Results from a list of LintResults.
 *
 * @param taskContext {Task} This is used to set Task properties on the Result
 * @param lintResults {LintResult[]} The LintResults used to create Result
 * @param [additionalData] {Object} Any additional data to be put into the properties bag
 * @param [customMessages] {Record<string, string>} Custom messages to be rendered for each lintRule
 */
function fromLintResults(taskContext, lintResults, additionalData = {}, customMessages = {}) {
    if (lintResults.length === 0) {
        return buildEmptyResult(taskContext);
    }
    // When files disable lint rules that are not defined in the context of our Task's parser, it adds a lintResult
    // that indicates that the rule was not found. Since this is not an actual error || warning, we filter them out
    const lintRuleNotDefinedRegex = new RegExp('Definition for rule .* was not found');
    return lintResults
        .filter((lintResult) => {
        return lintRuleNotDefinedRegex.test(lintResult.message) === false;
    })
        .map((lintResult) => {
        var _a;
        let message = (_a = (lintResult.lintRuleId && customMessages[lintResult.lintRuleId])) !== null && _a !== void 0 ? _a : lintResult.message;
        return {
            locations: buildLocationDataFromLintResult(lintResult),
            message: { text: message },
            occurrenceCount: 1,
            ruleId: taskContext.taskName,
            properties: Object.assign(Object.assign({
                taskDisplayName: taskContext.taskDisplayName,
                category: taskContext.category,
                group: taskContext.group,
            }, additionalData), { lintRuleId: lintResult.lintRuleId }),
        };
    });
}
/**
 * Builds SARIF Results from a list of locations.
 *
 * @param taskContext {Task} This is used to set Task properties on the Result
 * @param locations {string[]} The paths used to create Result
 * @param message {string} The message that identifies the data represented in the Result
 */
function fromLocations(taskContext, locations, message) {
    if (locations.length === 0) {
        return buildEmptyResult(taskContext, message);
    }
    return locations.map((path) => {
        return {
            locations: buildLocationDataFromPath(path),
            message: { text: message },
            occurrenceCount: 1,
            ruleId: taskContext.taskName,
            properties: {
                taskDisplayName: taskContext.taskDisplayName,
                category: taskContext.category,
                group: taskContext.group,
            },
        };
    });
}
/**
 * Builds SARIF Results from a list of properties.
 *
 * @param taskContext {Task} This is used to set Task properties on the Result
 * @param key {string} An identifier used to help identify the result
 * @param data {Array<string | object>} The raw data used to derive the result's count
 */
function fromData(taskContext, data, message) {
    if (data.length === 0) {
        return buildEmptyResult(taskContext, message);
    }
    return [
        {
            message: { text: message },
            ruleId: taskContext.taskName,
            occurrenceCount: data.length,
            properties: Object.assign({ data: data }, {
                taskDisplayName: taskContext.taskDisplayName,
                category: taskContext.category,
                group: taskContext.group,
            }),
        },
    ];
}
function fromTaskErrors(errors) {
    return errors.map((error) => {
        return {
            message: { text: error.error.message },
            associatedRule: {
                id: error.taskName,
            },
            properties: { fullError: error.error.stack },
        };
    });
}
exports.fromTaskErrors = fromTaskErrors;
exports.sarifBuilder = {
    fromLintResults,
    fromLocations,
    fromData,
    notifications: {
        fromTaskErrors,
    },
};
function buildEmptyResult(taskContext, consoleMessage) {
    return [
        {
            message: { text: exports.NO_RESULTS_FOUND },
            ruleId: taskContext.taskName,
            properties: Object.assign({ consoleMessage }, {
                taskDisplayName: taskContext.taskDisplayName,
                category: taskContext.category,
                group: taskContext.group,
            }),
        },
    ];
}
/**
 * @param lintResult {LintResult}
 * @returns Location[]
 */
function buildLocationDataFromLintResult(lintResult) {
    const location = {
        physicalLocation: {
            artifactLocation: {
                uri: lintResult.filePath,
            },
        },
    };
    if ((lintResult.line > 0 || lintResult.column > 0) &&
        location &&
        location.physicalLocation !== undefined) {
        location.physicalLocation.region = {};
        if (lintResult.line > 0) {
            location.physicalLocation.region.startLine = lintResult.line;
        }
        if (lintResult.column > 0) {
            location.physicalLocation.region.startColumn = lintResult.column;
        }
    }
    return [location];
}
/**
 * @param paths {string[]}
 * @returns Location[]
 */
function buildLocationDataFromPath(path) {
    return [
        {
            physicalLocation: {
                artifactLocation: {
                    uri: path,
                },
            },
        },
    ];
}
//# sourceMappingURL=sarif.js.map