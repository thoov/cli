"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizePaths = exports.normalizePath = exports.buildNotificationsFromTaskErrors = exports.buildLintResultsFromEslintOrTemplateLint = exports.buildLintResultDataItem = exports.buildLintResultData = exports.buildResultsFromProperties = exports.buildResultsFromPathArray = exports.buildResultsFromLintResult = exports.NO_RESULTS_FOUND = void 0;
exports.NO_RESULTS_FOUND = 'No results found';
/**
 * @param lintResult {LintResult}
 * @returns Location[]
 */
function buildLocationDataFromLintResult(lintResult) {
    const location = {
        physicalLocation: {
            artifactLocation: {
                uri: lintResult.filePath,
            },
        },
    };
    if ((lintResult.line > 0 || lintResult.column > 0) &&
        location &&
        location.physicalLocation !== undefined) {
        location.physicalLocation.region = {};
        if (lintResult.line > 0) {
            location.physicalLocation.region.startLine = lintResult.line;
        }
        if (lintResult.column > 0) {
            location.physicalLocation.region.startColumn = lintResult.column;
        }
    }
    return [location];
}
/**
 * @param paths {string[]}
 * @returns Location[]
 */
function buildLocationDataFromPath(path) {
    return [
        {
            physicalLocation: {
                artifactLocation: {
                    uri: path,
                },
            },
        },
    ];
}
/**
 * @param taskContext {Task} This is used to set Task properties on the Result
 * @param lintResults {LintResult[]} The LintResults used to create Result
 * @param [additionalData] {Object} Any additional data to be put into the properties bag
 * @param [customMessages] {Record<string, string>} Custom messages to be rendered for each lintRule
 */
function buildResultsFromLintResult(taskContext, lintResults, additionalData = {}, customMessages = {}) {
    if (lintResults.length === 0) {
        return buildEmptyResult(taskContext);
    }
    // When files disable lint rules that are not defined in the context of our Task's parser, it adds a lintResult
    // that indicates that the rule was not found. Since this is not an actual error || warning, we filter them out
    const lintRuleNotDefinedRegex = new RegExp('Definition for rule .* was not found');
    return lintResults
        .filter((lintResult) => {
        return lintRuleNotDefinedRegex.test(lintResult.message) === false;
    })
        .map((lintResult) => {
        var _a;
        let message = (_a = (lintResult.lintRuleId && customMessages[lintResult.lintRuleId])) !== null && _a !== void 0 ? _a : lintResult.message;
        return {
            locations: buildLocationDataFromLintResult(lintResult),
            message: { text: message },
            occurrenceCount: 1,
            ruleId: taskContext.taskName,
            properties: Object.assign(Object.assign({
                taskDisplayName: taskContext.taskDisplayName,
                category: taskContext.category,
                group: taskContext.group,
            }, additionalData), { lintRuleId: lintResult.lintRuleId }),
        };
    });
}
exports.buildResultsFromLintResult = buildResultsFromLintResult;
/**
 * @param taskContext {Task} This is used to set Task properties on the Result
 * @param paths {string[]} The paths used to create Result
 * @param message {string} The message that identifies the data represented in the Result
 */
function buildResultsFromPathArray(taskContext, paths, message) {
    if (paths.length === 0) {
        return buildEmptyResult(taskContext, message);
    }
    return paths.map((path) => {
        return {
            locations: buildLocationDataFromPath(path),
            message: { text: message },
            occurrenceCount: 1,
            ruleId: taskContext.taskName,
            properties: {
                taskDisplayName: taskContext.taskDisplayName,
                category: taskContext.category,
                group: taskContext.group,
            },
        };
    });
}
exports.buildResultsFromPathArray = buildResultsFromPathArray;
/**
 * @param taskContext {Task} This is used to set Task properties on the Result
 * @param key {string} An identifier used to help identify the result
 * @param data {Array<string | object>} The raw data used to derive the result's count
 */
function buildResultsFromProperties(taskContext, data, message) {
    if (data.length === 0) {
        return buildEmptyResult(taskContext, message);
    }
    return [
        {
            message: { text: message },
            ruleId: taskContext.taskName,
            occurrenceCount: data.length,
            properties: Object.assign({ data: data }, {
                taskDisplayName: taskContext.taskDisplayName,
                category: taskContext.category,
                group: taskContext.group,
            }),
        },
    ];
}
exports.buildResultsFromProperties = buildResultsFromProperties;
function buildEmptyResult(taskContext, consoleMessage) {
    return [
        {
            message: { text: exports.NO_RESULTS_FOUND },
            ruleId: taskContext.taskName,
            properties: Object.assign({ consoleMessage }, {
                taskDisplayName: taskContext.taskDisplayName,
                category: taskContext.category,
                group: taskContext.group,
            }),
        },
    ];
}
function buildLintResultData(report, cwd) {
    return report.results.reduce((transformed, lintResult) => {
        let messages = lintResult.messages.map((lintMessage) => {
            return buildLintResultDataItem(lintMessage, cwd, lintResult.filePath);
        });
        transformed.push(...messages);
        return transformed;
    }, []);
}
exports.buildLintResultData = buildLintResultData;
function buildLintResultDataItem(message, cwd, filePath, additionalData = {}) {
    return Object.assign({ filePath: normalizePath(filePath, cwd), lintRuleId: getLintRuleId(message), message: message.message, severity: message.severity, line: message.line, column: message.column }, additionalData);
}
exports.buildLintResultDataItem = buildLintResultDataItem;
function buildLintResultsFromEslintOrTemplateLint(lintResults, cwd) {
    return lintResults.reduce((resultDataItems, lintingResults) => {
        const messages = lintingResults.messages.map((lintMessage) => {
            return buildLintResultDataItem(lintMessage, cwd, lintingResults.filePath);
        });
        resultDataItems.push(...messages);
        return resultDataItems;
    }, []);
}
exports.buildLintResultsFromEslintOrTemplateLint = buildLintResultsFromEslintOrTemplateLint;
function getLintRuleId(message) {
    if (typeof message.ruleId !== 'undefined') {
        return message.ruleId;
    }
    else if (typeof message.rule !== 'undefined') {
        return message.rule;
    }
    return '';
}
function buildNotificationsFromTaskErrors(errors) {
    return errors.map((error) => {
        return {
            message: { text: error.error.message },
            associatedRule: {
                id: error.taskName,
            },
            properties: { fullError: error.error.stack },
        };
    });
}
exports.buildNotificationsFromTaskErrors = buildNotificationsFromTaskErrors;
function normalizePath(path, cwd) {
    return path.replace(`${cwd}/`, '');
}
exports.normalizePath = normalizePath;
function normalizePaths(paths, cwd) {
    return paths.map((path) => normalizePath(path, cwd));
}
exports.normalizePaths = normalizePaths;
//# sourceMappingURL=builders.js.map