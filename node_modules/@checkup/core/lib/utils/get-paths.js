"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilePaths = exports.getFilePathsAsync = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const file_path_array_1 = require("./file-path-array");
const isValidGlob = require('is-valid-glob');
const micromatch = require('micromatch');
const walkSync = require('walk-sync');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const PATHS_TO_IGNORE = [
    '**/node_modules/**',
    'bower_components/**',
    '**/tests/dummy/**',
    'concat-stats-for/**',
    'dist/**',
    'build/**',
    'vendor/**',
    '.git/**',
    '**/*.log',
    '*.log',
];
function getFilePathsAsync(basePath, globs = [], excludePaths = []) {
    return new Promise((resolve, reject) => {
        const worker = new Worker(__filename, {
            workerData: { basePath, globs, excludePaths },
        });
        worker.on('message', resolve);
        worker.on('error', reject);
        worker.on('exit', (code) => {
            if (code !== 0) {
                reject(new Error(`Worker stopped with exit code ${code}`));
            }
        });
    });
}
exports.getFilePathsAsync = getFilePathsAsync;
/**
 * @param basePath
 */
function getFilePaths(basePath, globs = [], excludePaths = []) {
    let mergedPathsToIgnore = [...excludePaths, ...PATHS_TO_IGNORE];
    if (globs.length > 0) {
        return expandFileGlobs(globs, basePath, mergedPathsToIgnore);
    }
    const allFiles = walkSync(basePath, {
        ignore: mergedPathsToIgnore,
        directories: false,
        globOptions: { dot: true },
    });
    return resolveFilePaths(allFiles, basePath);
}
exports.getFilePaths = getFilePaths;
function expandFileGlobs(filePatterns, basePath, excludePaths) {
    return new file_path_array_1.FilePathArray(...filePatterns.flatMap((pattern) => {
        let isLiteralPath = !isValidGlob(pattern) && fs_1.existsSync(pattern);
        if (isLiteralPath) {
            let isIgnored = !micromatch.isMatch(pattern, excludePaths);
            if (!isIgnored) {
                return pattern;
            }
            return [];
        }
        let expandedGlobs = walkSync(basePath, {
            globs: [pattern],
            directories: false,
            ignore: excludePaths,
        });
        return resolveFilePaths(expandedGlobs, basePath);
    }));
}
function resolveFilePaths(filePaths, basePath) {
    if (basePath !== '.') {
        let resolvedPaths = filePaths.map((pathName) => {
            return path_1.join(path_1.resolve(basePath), pathName);
        });
        return new file_path_array_1.FilePathArray(...resolvedPaths);
    }
    return new file_path_array_1.FilePathArray(...filePaths);
}
if (require.main === module) {
    if (!isMainThread) {
        parentPort.postMessage(getFilePaths(workerData.basePath, workerData.globs, workerData.excludePaths));
    }
}
//# sourceMappingURL=get-paths.js.map