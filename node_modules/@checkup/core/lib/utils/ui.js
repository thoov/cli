"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ui = exports.calculateSectionBar = void 0;
const chalk = require("chalk");
const cli_ux_1 = require("cli-ux");
const lodash_1 = require("lodash");
function calculateSectionBar(segments, total, width) {
    // We want to normalize the amount provided by the proper ratios.
    // If the total is less than the width we want to multiply the ratio.
    // If the total is greater than the width we want to divide the amount vs the ratio
    const normalizeSegment = function (amount) {
        return Math.ceil(total < width ? amount * (width / total) : amount / (total / width));
    };
    const completedSegments = segments
        .map((segment) => {
        return Object.assign({}, segment, {
            completed: normalizeSegment(segment.count),
        });
    })
        .sort((a, b) => {
        if (a.count === b.count) {
            return a.title > b.title ? 1 : -1;
        }
        return b.count - a.count;
    });
    // remove  the segments counts from the total number and then normalize it by the barSegment ratio
    const incompleteSegments = normalizeSegment(total - completedSegments.reduce((prev, curr) => prev + curr.count, 0));
    // if incompleteSegments is a negative number resulting from overflow we return 0
    return {
        completedSegments,
        incompleteSegments: incompleteSegments > 0 ? incompleteSegments : 0,
    };
}
exports.calculateSectionBar = calculateSectionBar;
exports.ui = Object.assign(cli_ux_1.ux, {
    blankLine() {
        process.stdout.write('\n');
    },
    clearScreen() {
        process.stdout.write('\u001B[2J');
    },
    clearLine() {
        process.stdout.write('\u001B[0f');
    },
    categoryHeader(header) {
        exports.ui.styledHeader(header);
        exports.ui.blankLine();
    },
    sectionHeader(header) {
        process.stdout.write(this.emphasize(`${chalk.underline(lodash_1.startCase(header))}\n`));
        exports.ui.blankLine();
    },
    section(header, contents) {
        exports.ui.sectionHeader(header);
        contents();
        exports.ui.blankLine();
    },
    subHeader(header) {
        process.stdout.write(`${chalk.underline(lodash_1.startCase(header))}\n`);
        exports.ui.blankLine();
    },
    subSection(header, contents) {
        exports.ui.subHeader(header);
        contents();
        exports.ui.blankLine();
    },
    dimmed(format) {
        exports.ui.log(chalk.dim(format));
    },
    emphasize(format) {
        return chalk.bold(format);
    },
    bar(title, complete, total, unit = '', maximum = 50) {
        const barTick = '■';
        const barSegment = Math.ceil(total / maximum);
        const completedSegments = Math.ceil(complete / barSegment);
        const incompleteSegments = maximum - completedSegments;
        const bar = `${exports.ui.randomColor()(barTick.repeat(completedSegments))}${chalk.grey(barTick.repeat(Math.max(0, incompleteSegments)))}`;
        exports.ui.log(title);
        exports.ui.log(`${bar} ${complete.toLocaleString()}${unit}`);
        exports.ui.blankLine();
    },
    sectionedBar(segments, total, unit = '', width = 50) {
        const barTick = '■';
        const colors = this.colors();
        segments.forEach((segment, i) => {
            segment.color = colors[i + 3];
        });
        const { completedSegments, incompleteSegments } = calculateSectionBar(segments, total, width);
        const bar = `${completedSegments
            .map((segment) => segment.color(barTick.repeat(segment.completed)))
            .join('')}${chalk.grey(barTick.repeat(Math.max(0, incompleteSegments)))}`;
        if (incompleteSegments > 0) {
            completedSegments.push({
                title: 'unknown',
                completed: incompleteSegments,
                count: incompleteSegments,
                color: chalk.grey,
            });
        }
        exports.ui.log(`${bar} ${total.toLocaleString()} ${unit}`);
        completedSegments.map((segment) => exports.ui.log(`${segment.color(barTick)} ${segment.title} (${segment.count.toLocaleString()})`));
    },
    valuesList(values, unit = '', color = exports.ui.randomColor()) {
        values.forEach((value) => {
            exports.ui.value(value, unit, color);
        });
    },
    value(value, unit = '', color = exports.ui.randomColor()) {
        exports.ui.log(`${color('■')} ${value.title} (${value.count.toLocaleString()}${unit ? ' ' + unit : ''})`);
    },
    randomColor() {
        const colors = this.colors();
        return colors[Math.floor(Math.random() * colors.length)];
    },
    colors(range = 70) {
        const ANSI_CODE_START = 33;
        // eslint-disable-next-line unicorn/no-useless-undefined
        return new Array(range).fill(undefined).map((_, i) => chalk.ansi256(i + ANSI_CODE_START));
    },
    getColor(color) {
        if (typeof color === 'string') {
            return chalk.keyword(color);
        }
        return color;
    },
});
//# sourceMappingURL=ui.js.map