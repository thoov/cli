"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConfigTuple = exports.validateConfig = exports.writeConfig = exports.mergeConfig = exports.readConfig = exports.getConfigPathFromOptions = exports.getConfigPath = exports.DEFAULT_CONFIG = exports.CONFIG_SCHEMA_URL = exports.CONFIG_DOCS_URL = void 0;
const Ajv = require("ajv");
const node_fetch_1 = require("node-fetch");
const tmp = require("tmp");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const checkup_error_1 = require("./errors/checkup-error");
const chalk_1 = require("chalk");
const plugin_name_1 = require("./utils/plugin-name");
const debug = require('debug')('checkup:config');
const schema = require('./schemas/config-schema.json');
exports.CONFIG_DOCS_URL = 'https://docs.checkupjs.com/quickstart/usage#1-generate-a-configuration-file';
exports.CONFIG_SCHEMA_URL = 'https://raw.githubusercontent.com/checkupjs/checkup/master/packages/core/src/schemas/config-schema.json';
exports.DEFAULT_CONFIG = {
    $schema: exports.CONFIG_SCHEMA_URL,
    excludePaths: [],
    plugins: [],
    tasks: {},
};
function getConfigPath(path = '') {
    return path_1.join(path_1.resolve(path), '.checkuprc');
}
exports.getConfigPath = getConfigPath;
async function getConfigPathFromOptions(configPath) {
    if (!configPath) {
        return;
    }
    if (configPath.startsWith('http')) {
        const contents = await downloadFile(configPath);
        const filePath = tmp.fileSync();
        await fs_extra_1.writeJSON(filePath.name, contents);
        return filePath.name;
    }
    else {
        configPath;
    }
}
exports.getConfigPathFromOptions = getConfigPathFromOptions;
async function downloadFile(url) {
    let response = await node_fetch_1.default(url);
    return response.json();
}
function readConfig(configPath) {
    let config;
    debug(`Reading config from ${configPath}`);
    try {
        config = fs_extra_1.readJsonSync(path_1.resolve(configPath || getConfigPath()));
    }
    catch (error) {
        if (error instanceof SyntaxError) {
            let hint = error.message.replace(/.*:\s(.*)/, '$1');
            throw new checkup_error_1.default(`The checkup config at ${configPath} contains invalid JSON.\nError: ${hint}`, 'Fix the syntax error in your .checkuprc before continuing.');
        }
        throw new checkup_error_1.default(`Could not find a checkup config in the given path: ${configPath}.`, `See ${exports.CONFIG_DOCS_URL} for more info on how to setup a config.`);
    }
    debug(`Found config %O`, config);
    config.plugins.forEach((pluginName, index, arr) => {
        arr[index] = plugin_name_1.normalizePackageName(pluginName);
    });
    validateConfig(config, configPath);
    return config;
}
exports.readConfig = readConfig;
function mergeConfig(config) {
    return Object.assign(Object.assign({}, exports.DEFAULT_CONFIG), config);
}
exports.mergeConfig = mergeConfig;
function writeConfig(dir, config = {}) {
    let path = getConfigPath(dir);
    if (fs_extra_1.existsSync(path)) {
        throw new Error(`There is already an existing config in ${dir}`);
    }
    try {
        fs_extra_1.writeJsonSync(path, mergeConfig(config), { spaces: 2 });
    }
    catch (_a) {
        throw new Error(`Cannot write config to ${dir}.`);
    }
    return path;
}
exports.writeConfig = writeConfig;
function validateConfig(config, configPath) {
    const ajv = new Ajv();
    const validate = ajv.compile(schema);
    if (!validate(config)) {
        let error = `\n\n${chalk_1.white.bold('Details')}: ${(validate.errors && validate.errors.length > 0 && ajv.errorsText(validate.errors)) || ''}.`;
        throw new checkup_error_1.default(`Config in ${configPath} is invalid.${error}`, `See ${exports.CONFIG_DOCS_URL} for more information on correct config formats.`);
    }
}
exports.validateConfig = validateConfig;
function parseConfigTuple(configValue) {
    let enabled = true;
    let value = {};
    if (typeof configValue === 'string') {
        enabled = configValue === 'on';
    }
    else if (Array.isArray(configValue)) {
        let [enabledStr, val] = configValue;
        enabled = enabledStr === 'on';
        value = val;
    }
    return [enabled, value];
}
exports.parseConfigTuple = parseConfigTuple;
//# sourceMappingURL=config.js.map