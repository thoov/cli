"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTaskCommand = exports._resetTasksForTesting = exports._registerTaskForTesting = void 0;
const core_1 = require("@checkup/core");
const base_command_1 = require("./base-command");
const task_list_1 = require("./task-list");
const get_log_1 = require("./get-log");
const task_errors_1 = require("./task-errors");
const get_package_json_1 = require("./utils/get-package-json");
const get_reporter_1 = require("./reporters/get-reporter");
const available_task_reporter_1 = require("./reporters/available-task-reporter");
let __tasksForTesting = new Set();
function _registerTaskForTesting(task) {
    __tasksForTesting.add(task);
}
exports._registerTaskForTesting = _registerTaskForTesting;
function _resetTasksForTesting() {
    __tasksForTesting = new Set();
}
exports._resetTasksForTesting = _resetTasksForTesting;
class BaseTaskCommand extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.pluginTasks = new task_list_1.default();
        this.pluginTaskResults = [];
        this.pluginTaskErrors = [];
        this.startTime = '';
        this.actions = [];
        this.cliModeEnabled = true;
    }
    get taskFilterType() {
        if (this.runFlags.task !== undefined) {
            return 'task';
        }
        else if (this.runFlags.category !== undefined) {
            return 'category';
        }
        else if (this.runFlags.group !== undefined) {
            return 'group';
        }
        return '';
    }
    async run() {
        await this.loadConfig();
        await this.register();
        if (this.runFlags['list-tasks']) {
            this.printAvailableTasks();
        }
        else {
            if (this.cliModeEnabled) {
                core_1.ui.action.start('Checking up on your project');
            }
            await this.runTasks();
            await this.runActions();
            let log = await get_log_1.getLog(this.taskContext, this.pluginTaskResults, this.actions, this.getInvocation(this.pluginTaskErrors), this.pluginTasks, this.executedTasks);
            if (this.cliModeEnabled) {
                this.report(log);
                core_1.ui.action.stop();
            }
            return log;
        }
    }
    async runTasks() {
        if (this.taskFilterType) {
            let { tasksFound, tasksNotFound } = this.findTasks();
            if (tasksFound.length > 0) {
                [this.pluginTaskResults, this.pluginTaskErrors] = await this.pluginTasks.runTasks(tasksFound);
            }
            if (tasksNotFound.length > 0) {
                let error = task_errors_1.TASK_ERRORS.get(this.taskFilterType);
                this.extendedError(new core_1.CheckupError(error.message(tasksNotFound), error.callToAction));
                core_1.ui.action.stop();
            }
            this.executedTasks = tasksFound;
        }
        else {
            [this.pluginTaskResults, this.pluginTaskErrors] = await this.pluginTasks.runTasks();
            this.executedTasks = this.pluginTasks.getTasks();
        }
    }
    findTasks() {
        if (this.runFlags.task !== undefined) {
            return this.pluginTasks.findAllByTaskName(...this.runFlags.task);
        }
        else if (this.runFlags.category !== undefined) {
            return this.pluginTasks.findAllByCategory(...this.runFlags.category);
        }
        else if (this.runFlags.group !== undefined) {
            return this.pluginTasks.findAllByGroup(...this.runFlags.group);
        }
        return { tasksFound: [], tasksNotFound: [] };
    }
    runActions() {
        return new Promise((resolve, reject) => {
            let evaluators = core_1.getRegisteredActions();
            for (let [taskName, evaluator] of evaluators) {
                let task = this.pluginTasks.find(taskName);
                let taskResult = this.pluginTaskResults.filter((result) => {
                    var _a;
                    return ((_a = result.properties) === null || _a === void 0 ? void 0 : _a.taskName) === taskName;
                });
                if (task && taskResult.length > 0) {
                    try {
                        this.actions.push(...evaluator(taskResult, task.config));
                    }
                    catch (error) {
                        reject(error);
                    }
                }
            }
            resolve();
        });
    }
    async loadConfig() {
        let configPath;
        try {
            configPath =
                (await core_1.getConfigPathFromOptions(this.runFlags.config)) || core_1.getConfigPath(this.runFlags.cwd);
            this.checkupConfig = core_1.readConfig(configPath);
            let plugins = await core_1.loadPlugins(this.checkupConfig.plugins, this.runFlags.cwd);
            this.config.plugins.push(...plugins);
        }
        catch (error) {
            this.extendedError(error);
        }
    }
    async register() {
        await this.config.runHook('register-parsers', {
            registerParser: core_1.registerParser,
        });
        await this.config.runHook('register-actions', {
            registerActions: core_1.registerActions,
        });
        await this.config.runHook('register-task-reporter', {
            registerTaskReporter: core_1.registerTaskReporter,
        });
        // if excludePaths are provided both via the command line and config, the command line is prioritized
        let excludePaths = this.runFlags['exclude-paths'] || this.checkupConfig.excludePaths;
        this.taskContext = Object.freeze({
            cliArguments: this.runArgs,
            cliFlags: this.runFlags,
            parsers: core_1.getRegisteredParsers(),
            config: this.checkupConfig,
            pkg: get_package_json_1.getPackageJson(this.runFlags.cwd),
            paths: core_1.FilePathArray.from(await core_1.getFilePathsAsync(this.runFlags.cwd, this.runArgs, excludePaths)),
        });
        this.registerTasks();
        __tasksForTesting.forEach((task) => {
            this.pluginTasks.registerTask(task);
        });
    }
    report(log) {
        let generateReport = get_reporter_1.getReporter(this.runFlags);
        generateReport(log, this.runFlags);
    }
    printAvailableTasks() {
        available_task_reporter_1.reportAvailableTasks(this.pluginTasks);
    }
    getInvocation(errors) {
        return {
            arguments: this.runArgs,
            executionSuccessful: true,
            endTimeUtc: new Date().toJSON(),
            environmentVariables: {
                cwd: this.runFlags.cwd,
                outputFile: this.runFlags['output-file'],
                format: this.runFlags.format,
            },
            toolExecutionNotifications: core_1.sarifBuilder.notifications.fromTaskErrors(errors),
            startTimeUtc: this.startTime,
        };
    }
}
exports.BaseTaskCommand = BaseTaskCommand;
//# sourceMappingURL=base-task-command.js.map