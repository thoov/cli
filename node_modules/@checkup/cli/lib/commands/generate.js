"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require("chalk");
const debug = require("debug");
const path_1 = require("path");
const fs_1 = require("fs");
const base_command_1 = require("../base-command");
const yeoman_environment_1 = require("yeoman-environment");
const command_1 = require("@oclif/command");
const core_1 = require("@checkup/core");
const VALID_GENERATORS = ['config', 'plugin', 'task', 'actions'];
class GenerateCommand extends base_command_1.BaseCommand {
    constructor(argv, config) {
        super(argv, config);
        this.baseDir = process.cwd();
        this.debug = debug('checkup:generator');
    }
    async run() {
        const { flags, args } = this.parse(GenerateCommand);
        this.debug('available generators', VALID_GENERATORS);
        if (!VALID_GENERATORS.includes(args.type)) {
            this.extendedError(new core_1.CheckupError(`No valid generator found for ${chalk.bold.white(args.type)}`, `Valid generators are ${chalk.bold.white(VALID_GENERATORS.join(', '))}`));
        }
        await this.generate(args.type, {
            name: args.name,
            path: flags.path,
            defaults: flags.defaults,
            force: flags.force,
        });
    }
    async generate(type, generatorOptions) {
        this.debug('generatorOptions', generatorOptions);
        const env = yeoman_environment_1.createEnv();
        env.register(require.resolve(`../generators/${type}`), `checkup:${type}`);
        try {
            await new Promise((resolve, reject) => {
                env.run(`checkup:${type}`, generatorOptions, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        // this is ugly, but I couldn't find the correct configuration to ignore
                        // generating the yeoman repository directory in the cwd
                        let yoRepoPath = path_1.join(this.baseDir, '.yo-repository');
                        if (fs_1.existsSync(yoRepoPath)) {
                            fs_1.rmdirSync(yoRepoPath);
                        }
                        resolve();
                    }
                });
            });
        }
        catch (error) {
            if (!(error instanceof core_1.CheckupError)) {
                // eslint-disable-next-line no-ex-assign
                error = new core_1.CheckupError(`Could not run the ${type} generator.`, error.message);
            }
            this.extendedError(error);
        }
    }
}
exports.default = GenerateCommand;
GenerateCommand.description = 'Runs a generator to scaffold Checkup code';
GenerateCommand.flags = {
    defaults: command_1.flags.boolean({ description: 'use defaults for every setting' }),
    options: command_1.flags.string({ description: '(typescript)' }),
    force: command_1.flags.boolean({ description: 'overwrite existing files' }),
    path: command_1.flags.string({
        default: '.',
        char: 'p',
        description: 'The path referring to the directory that the generator will run in',
    }),
};
GenerateCommand.args = [
    {
        name: 'type',
        required: true,
        description: 'type of generator to run (config, plugin, task, actions)',
    },
    {
        name: 'name',
        description: 'name of the entity (kebab-case)',
    },
];
//# sourceMappingURL=generate.js.map