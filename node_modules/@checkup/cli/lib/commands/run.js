"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._resetTasksForTesting = exports._registerTaskForTesting = void 0;
const core_1 = require("@checkup/core");
const command_1 = require("@oclif/command");
const base_command_1 = require("../base-command");
const task_list_1 = require("../task-list");
const get_package_json_1 = require("../utils/get-package-json");
const get_reporter_1 = require("../reporters/get-reporter");
const get_log_1 = require("../get-log");
const available_task_reporter_1 = require("../reporters/available-task-reporter");
const task_errors_1 = require("../task-errors");
let __tasksForTesting = new Set();
function _registerTaskForTesting(task) {
    __tasksForTesting.add(task);
}
exports._registerTaskForTesting = _registerTaskForTesting;
function _resetTasksForTesting() {
    __tasksForTesting = new Set();
}
exports._resetTasksForTesting = _resetTasksForTesting;
class RunCommand extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.pluginTasks = new task_list_1.default();
        this.pluginTaskResults = [];
        this.pluginTaskErrors = [];
        this.startTime = '';
        this.actions = [];
        this.cliModeEnabled = true;
    }
    get taskFilterType() {
        if (this.runFlags.task !== undefined) {
            return 'task';
        }
        else if (this.runFlags.category !== undefined) {
            return 'category';
        }
        else if (this.runFlags.group !== undefined) {
            return 'group';
        }
        return '';
    }
    async init() {
        let { argv, flags } = this.parse(RunCommand);
        if (flags['output-file'] && flags.format !== core_1.OutputFormat.json) {
            this.error(new Error('Missing --format flag. --format=json must also be provided when using --output-file'));
        }
        this.startTime = new Date().toJSON();
        this.runArgs = argv;
        this.runFlags = flags;
        this.cliModeEnabled = process.env.CHECKUP_CLI === '1';
    }
    async run() {
        await this.loadConfig();
        await this.register();
        if (this.runFlags['list-tasks']) {
            this.printAvailableTasks();
        }
        else {
            if (this.cliModeEnabled) {
                core_1.ui.action.start('Checking up on your project');
            }
            await this.runTasks();
            await this.runActions();
            let log = await get_log_1.getLog(this.taskContext, this.pluginTaskResults, this.actions, this.getInvocation(this.pluginTaskErrors), this.pluginTasks, this.executedTasks);
            if (this.cliModeEnabled) {
                this.report(log);
                core_1.ui.action.stop();
            }
            return log;
        }
    }
    async runTasks() {
        if (this.taskFilterType) {
            let { tasksFound, tasksNotFound } = this.findTasks();
            if (tasksFound.length > 0) {
                [this.pluginTaskResults, this.pluginTaskErrors] = await this.pluginTasks.runTasks(tasksFound);
            }
            if (tasksNotFound.length > 0) {
                let error = task_errors_1.TASK_ERRORS.get(this.taskFilterType);
                this.extendedError(new core_1.CheckupError(error.message(tasksNotFound), error.callToAction));
                core_1.ui.action.stop();
            }
            this.executedTasks = tasksFound;
        }
        else {
            [this.pluginTaskResults, this.pluginTaskErrors] = await this.pluginTasks.runTasks();
            this.executedTasks = this.pluginTasks.getTasks();
        }
    }
    findTasks() {
        if (this.runFlags.task !== undefined) {
            return this.pluginTasks.findAllByTaskName(...this.runFlags.task);
        }
        else if (this.runFlags.category !== undefined) {
            return this.pluginTasks.findAllByCategory(...this.runFlags.category);
        }
        else if (this.runFlags.group !== undefined) {
            return this.pluginTasks.findAllByGroup(...this.runFlags.group);
        }
        return { tasksFound: [], tasksNotFound: [] };
    }
    runActions() {
        return new Promise((resolve, reject) => {
            let evaluators = core_1.getRegisteredActions();
            for (let [taskName, evaluator] of evaluators) {
                let task = this.pluginTasks.find(taskName);
                let taskResult = this.pluginTaskResults.filter((result) => {
                    var _a;
                    return ((_a = result.properties) === null || _a === void 0 ? void 0 : _a.taskName) === taskName;
                });
                if (task && taskResult.length > 0) {
                    try {
                        this.actions.push(...evaluator(taskResult, task.config));
                    }
                    catch (error) {
                        reject(error);
                    }
                }
            }
            resolve();
        });
    }
    async loadConfig() {
        let configPath;
        try {
            configPath =
                (await core_1.getConfigPathFromOptions(this.runFlags.config)) || core_1.getConfigPath(this.runFlags.cwd);
            this.checkupConfig = core_1.readConfig(configPath);
            let plugins = await core_1.loadPlugins(this.checkupConfig.plugins, this.runFlags.cwd);
            this.config.plugins.push(...plugins);
        }
        catch (error) {
            this.extendedError(error);
        }
    }
    async register() {
        await this.config.runHook('register-parsers', {
            registerParser: core_1.registerParser,
        });
        await this.config.runHook('register-actions', {
            registerActions: core_1.registerActions,
        });
        await this.config.runHook('register-task-reporter', {
            registerTaskReporter: core_1.registerTaskReporter,
        });
        // if excludePaths are provided both via the command line and config, the command line is prioritized
        let excludePaths = this.runFlags['exclude-paths'] || this.checkupConfig.excludePaths;
        this.taskContext = Object.freeze({
            cliArguments: this.runArgs,
            cliFlags: this.runFlags,
            parsers: core_1.getRegisteredParsers(),
            config: this.checkupConfig,
            pkg: get_package_json_1.getPackageJson(this.runFlags.cwd),
            paths: core_1.FilePathArray.from(await core_1.getFilePathsAsync(this.runFlags.cwd, this.runArgs, excludePaths)),
        });
        await this.config.runHook('register-tasks', {
            context: this.taskContext,
            tasks: this.pluginTasks,
        });
        __tasksForTesting.forEach((task) => {
            this.pluginTasks.registerTask(task);
        });
    }
    report(log) {
        let generateReport = get_reporter_1.getReporter(this.runFlags);
        generateReport(log, this.runFlags);
    }
    printAvailableTasks() {
        available_task_reporter_1.reportAvailableTasks(this.pluginTasks);
    }
    getInvocation(errors) {
        return {
            arguments: this.runArgs,
            executionSuccessful: true,
            endTimeUtc: new Date().toJSON(),
            environmentVariables: {
                cwd: this.runFlags.cwd,
                outputFile: this.runFlags['output-file'],
                format: this.runFlags.format,
            },
            toolExecutionNotifications: core_1.buildNotificationsFromTaskErrors(errors),
            startTimeUtc: this.startTime,
        };
    }
}
exports.default = RunCommand;
RunCommand.description = 'A health checkup for your project';
// required for variable length command line arguments
RunCommand.strict = false;
RunCommand.usage = '[run] PATHS';
RunCommand.args = [
    {
        name: 'paths',
        description: 'The paths that checkup will operate on. If no paths are provided, checkup will run on the entire directory beginning at --cwd.',
    },
];
RunCommand.flags = {
    version: command_1.flags.version({ char: 'v' }),
    help: command_1.flags.help({ char: 'h' }),
    'exclude-paths': command_1.flags.string({
        description: 'Paths to exclude from checkup. If paths are provided via command line and via checkup config, command line paths will be used.',
        char: 'e',
        multiple: true,
    }),
    config: command_1.flags.string({
        char: 'c',
        description: 'Use this configuration, overriding .checkuprc.* if present.',
    }),
    cwd: command_1.flags.string({
        default: () => process.cwd(),
        char: 'd',
        description: 'The path referring to the root directory that Checkup will run in',
    }),
    category: command_1.flags.string({
        description: 'Runs specific tasks specified by category. Can be used multiple times.',
        multiple: true,
        exclusive: ['group', 'task'],
    }),
    group: command_1.flags.string({
        description: 'Runs specific tasks specified by group. Can be used multiple times.',
        multiple: true,
        exclusive: ['category', 'task'],
    }),
    task: command_1.flags.string({
        char: 't',
        description: 'Runs specific tasks specified by the fully qualified task name in the format pluginName/taskName. Can be used multiple times.',
        multiple: true,
        exclusive: ['category', 'group'],
    }),
    format: command_1.flags.string({
        char: 'f',
        options: [...Object.values(core_1.OutputFormat)],
        default: 'stdout',
        description: `The output format, one of ${[...Object.values(core_1.OutputFormat)].join(', ')}`,
    }),
    'output-file': command_1.flags.string({
        char: 'o',
        default: '',
        description: 'Specify file to write JSON output to. Requires the `--format` flag to be set to `json`',
    }),
    'list-tasks': command_1.flags.boolean({
        char: 'l',
        description: 'List all available tasks to run.',
    }),
    verbose: command_1.flags.boolean({
        exclusive: ['format', 'output-file'],
    }),
};
//# sourceMappingURL=run.js.map