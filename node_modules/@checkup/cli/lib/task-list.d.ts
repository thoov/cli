import * as debug from 'debug';
import { Task, TaskError, TaskName } from '@checkup/core';
import { Result } from 'sarif';
export declare type TaskFinderResult = {
    tasksFound: Task[];
    tasksNotFound: (TaskName | string)[];
};
/**
 * @class TaskList
 *
 * Represents a collection of tasks to run.
 */
export default class TaskList {
    private _categories;
    private _errors;
    private _timings;
    debug: debug.Debugger;
    get categories(): Map<string, Map<string, Task>>;
    get timings(): Record<string, number>;
    /**
     * @returns {string[]} The list of fully qualified task names.
     */
    get fullyQualifiedTaskNames(): string[];
    constructor();
    /**
     * Adds a default task to the task list, which is executed as part of checkup.
     *
     * @method registerTask
     * @param taskName {TaskName}
     * @param task {Task}
     * @param taskClassification
     */
    registerTask(task: Task): void;
    /**
     * Evaluates whether a task exists
     *
     * @method hasTask
     * @param taskName The name of the task to check for existence of
     */
    hasTask(taskName: TaskName): boolean;
    /**
     * Finds a task by task name
     *
     * @method findTask
     * @param taskName The name of the task to find
     */
    find(taskName: TaskName, predicate?: (task: Task) => boolean): Task | undefined;
    /**
     * Finds tasks by task name
     *
     * @method findTasks
     * @param taskNames The name of the task to find
     */
    findAllByTaskName(...taskNames: TaskName[]): TaskFinderResult;
    findAllByCategory(...categories: string[]): TaskFinderResult;
    findAllByGroup(...groups: string[]): TaskFinderResult;
    /**
     * Runs the task specified by the taskName parameter.
     *
     * @method runTask
     * @param {TaskName} taskName
     * @returns {Promise<[Result[], TaskError[]]>}
     * @memberof TaskList
     */
    runTask(taskName: TaskName): Promise<[Result[] | undefined, TaskError[]]>;
    /**
     * Runs all tasks that have been added to the task list.
     *
     * @method runTasks
     * @returns {Promise<[Result[], TaskError[]]>}
     * @memberof TaskList
     */
    runTasks(tasks?: Task[]): Promise<[Result[], TaskError[]]>;
    private _runTask;
    /**
     * Gets a taskTypeMap from the type map
     *
     * @private
     * @method getByCategory
     * @param category
     */
    private getByCategory;
    /**
     * Runs each task in parallel
     *
     * @private
     * @method eachTask
     * @param fn {Function} the function expressing the wrapped task to run
     * @returns {Promise<Result[][]>}
     */
    private eachTask;
    /**
     * Gets all tasks from all taskTypeMaps
     *
     * @private
     * @method getTasks
     */
    getTasks(): Task[];
    private addError;
}
//# sourceMappingURL=task-list.d.ts.map