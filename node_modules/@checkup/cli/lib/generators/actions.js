"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const t = require("@babel/types");
const recast = require("recast");
const traverse_1 = require("@babel/traverse");
const base_generator_1 = require("./base-generator");
const path_1 = require("path");
const core_1 = require("@checkup/core");
class ActionsGenerator extends base_generator_1.default {
    constructor(args, options) {
        super(args, options);
        this.options = options;
    }
    async prompting() {
        this.headline(`${this.options.name}-actions`);
        const defaults = {
            typescript: true,
        };
        if (this.options.defaults) {
            this.answers = defaults;
        }
        else {
            this.answers = await this.prompt([
                {
                    type: 'confirm',
                    name: 'typescript',
                    message: 'TypeScript',
                    default: () => true,
                },
                {
                    type: 'input',
                    name: 'taskName',
                    message: `Enter the task name that these actions will be associated with (the string value in the taskName property of the task class).`,
                },
            ]);
        }
        this.options.taskName = this.answers.taskName;
        this.options.pascalCaseName = _.upperFirst(_.camelCase(this.options.name));
        this.options.typescript = this.answers.typescript;
    }
    writing() {
        this.sourceRoot(path_1.join(__dirname, '../../templates/src/actions'));
        if (!this.fs.exists(this.destinationPath(`src/hooks/register-actions.${this._ext}`))) {
            this.fs.copy(this.templatePath(`src/hooks/register-actions.${this._ext}.ejs`), this.destinationPath(`src/hooks/register-actions.${this._ext}`));
        }
        this.fs.copyTpl(this.templatePath(`src/actions/actions.${this._ext}.ejs`), this.destinationPath(`src/actions/${this.options.name}-actions.${this._ext}`), this.options);
        this._transformHooks();
    }
    _transformHooks() {
        let hooksDestinationPath = this.destinationPath(`src/hooks/register-actions.${this._ext}`);
        let registerActionsSource = this.fs.read(hooksDestinationPath);
        let registerActionStatement = t.expressionStatement(t.callExpression(t.identifier('registerActions'), [
            t.stringLiteral(this.options.taskName),
            t.identifier(`evaluate${this.options.pascalCaseName}Actions`),
        ]));
        let newActionImportSpecifier = t.importSpecifier(t.identifier(`evaluate${this.options.pascalCaseName}Actions`), t.identifier('evaluateActions'));
        let tasksImportDeclaration = t.importDeclaration([newActionImportSpecifier], t.stringLiteral(`../actions/${this.options.name}-actions`));
        let code = new core_1.AstTransformer(registerActionsSource, recast.parse, traverse_1.default, {
            parser: require('recast/parsers/typescript'),
        })
            .traverse({
            Program(path) {
                path.node.body.splice(1, 0, tasksImportDeclaration);
            },
            BlockStatement(path) {
                path.node.body.push(registerActionStatement);
            },
        })
            .generate();
        this.fs.write(hooksDestinationPath, code);
    }
}
exports.default = ActionsGenerator;
//# sourceMappingURL=actions.js.map