"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const path = require("path");
const t = require("@babel/types");
const chalk = require("chalk");
const recast = require("recast");
const traverse_1 = require("@babel/traverse");
const base_generator_1 = require("./base-generator");
const core_1 = require("@checkup/core");
class TaskGenerator extends base_generator_1.default {
    constructor(args, options) {
        super(args, options);
        this.options = options;
    }
    async prompting() {
        this.packageJson = this.fs.readJSON('package.json');
        if (!this.packageJson ||
            !(this.packageJson.keywords && this.packageJson.keywords.includes('oclif-plugin'))) {
            throw new core_1.CheckupError('Can only generate tasks in Checkup plugin directory', `Run ${chalk.bold.white('checkup generate task')} from the root of a Checkup plugin or use the ${chalk.bold.white('--path')} option to specify the path to a Checkup plugin`);
        }
        this.headline(`${this.options.name}-task`);
        const defaults = {
            typescript: true,
        };
        if (this.options.defaults) {
            this.answers = defaults;
        }
        else {
            this.answers = await this.prompt([
                {
                    type: 'confirm',
                    name: 'typescript',
                    message: 'TypeScript',
                    default: () => true,
                },
                {
                    type: 'input',
                    name: 'category',
                    message: `Enter a task category. (Categories are used to group similar tasks together to help organize the results. eg: 'best practices', 'testing', etc.)`,
                },
                {
                    type: 'input',
                    name: 'group',
                    message: `(optional) Enter a task group. (Groups allow you to further group like tasks under categories)`,
                    optional: true,
                },
            ]);
        }
        this.options.pascalCaseName = _.upperFirst(_.camelCase(this.options.name));
        this.options.taskClass = `${this.options.pascalCaseName}Task`;
        this.options.typescript = this.answers.typescript;
        this.options.category = this.answers.category;
        this.options.group = this.answers.group;
    }
    writing() {
        this.sourceRoot(path.join(__dirname, '../../templates/src/task'));
        const options = Object.assign(Object.assign({}, this.options), { _ });
        this.fs.copyTpl(this.templatePath(`src/tasks/task.${this._ext}.ejs`), this.destinationPath(`src/tasks/${this.options.name}-task.${this._ext}`), options);
        this.fs.copyTpl(this.templatePath(`__tests__/task.${this._ext}.ejs`), this.destinationPath(`__tests__/${this.options.name}-task-test.${this._ext}`), options);
        this._transformHooks();
    }
    _transformHooks() {
        let hooksDestinationPath = this.destinationPath(`src/hooks/register-tasks.${this._ext}`);
        let registerTasksSource = this.fs.read(hooksDestinationPath);
        let registerTaskStatement = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('tasks'), t.identifier('registerTask')), [
            t.newExpression(t.identifier(this.options.taskClass), [
                t.identifier('pluginName'),
                t.identifier('context'),
            ]),
        ]));
        let newTaskImportSpecifier = t.importDefaultSpecifier(t.identifier(this.options.taskClass));
        let tasksImportDeclaration = t.importDeclaration([newTaskImportSpecifier], t.stringLiteral(`../tasks/${this.options.name}-task`));
        let code = new core_1.AstTransformer(registerTasksSource, recast.parse, traverse_1.default, {
            parser: require('recast/parsers/typescript'),
        })
            .traverse({
            Program(path) {
                path.node.body.splice(1, 0, tasksImportDeclaration);
            },
            BlockStatement(path) {
                path.node.body.push(registerTaskStatement);
            },
        })
            .generate();
        this.fs.write(hooksDestinationPath, code);
    }
}
exports.default = TaskGenerator;
//# sourceMappingURL=task.js.map