"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug = require("debug");
const pMap = require("p-map");
const convertHrtime = require("convert-hrtime");
const task_result_comparator_1 = require("./task-result-comparator");
/**
 * @class TaskList
 *
 * Represents a collection of tasks to run.
 */
class TaskList {
    constructor() {
        this._categories = new Map();
        this._errors = [];
        this._timings = {};
        this.debug = debug('checkup:task');
    }
    get categories() {
        return this._categories;
    }
    get timings() {
        return this._timings;
    }
    /**
     * @returns {string[]} The list of fully qualified task names.
     */
    get fullyQualifiedTaskNames() {
        return this.getTasks()
            .map((task) => task.fullyQualifiedTaskName)
            .sort();
    }
    /**
     * Adds a default task to the task list, which is executed as part of checkup.
     *
     * @method registerTask
     * @param taskName {TaskName}
     * @param task {Task}
     * @param taskClassification
     */
    registerTask(task) {
        if (task.category === '') {
            throw new Error(`Task category can not be empty. Please add a category to ${task.fullyQualifiedTaskName}-task.`);
        }
        let categoryMap = this.getByCategory(task.category);
        categoryMap.set(task.taskName, task);
    }
    /**
     * Evaluates whether a task exists
     *
     * @method hasTask
     * @param taskName The name of the task to check for existence of
     */
    hasTask(taskName) {
        return this.find(taskName) !== undefined;
    }
    /**
     * Finds a task by task name
     *
     * @method findTask
     * @param taskName The name of the task to find
     */
    find(taskName, predicate = (task) => task.taskName === taskName) {
        return this.getTasks().find(predicate);
    }
    /**
     * Finds tasks by task name
     *
     * @method findTasks
     * @param taskNames The name of the task to find
     */
    findAllByTaskName(...taskNames) {
        let tasksFound = [];
        let tasksNotFound = [];
        let availableTasks = this.getTasks();
        taskNames.forEach((taskName) => {
            let taskFound = false;
            for (let availableTask of availableTasks) {
                if (availableTask.fullyQualifiedTaskName === taskName) {
                    taskFound = true;
                    tasksFound.push(availableTask);
                    break;
                }
            }
            if (taskFound === false) {
                tasksNotFound.push(taskName);
            }
        });
        return { tasksFound, tasksNotFound };
    }
    findAllByCategory(...categories) {
        let tasksFound = [];
        let tasksNotFound = [];
        categories.forEach((category) => {
            let tasks = this._categories.get(category);
            if (tasks !== undefined) {
                tasksFound = [...tasksFound, ...tasks.values()];
            }
            else {
                tasksNotFound.push(category);
            }
        });
        return { tasksFound, tasksNotFound };
    }
    findAllByGroup(...groups) {
        let tasksFound = [];
        let tasksNotFound = [];
        let availableTasks = this.getTasks();
        groups.forEach((group) => {
            let taskFound = false;
            for (let availableTask of availableTasks) {
                if (availableTask.group === group) {
                    taskFound = true;
                    tasksFound.push(availableTask);
                }
            }
            if (taskFound === false) {
                tasksNotFound.push(group);
            }
        });
        return { tasksFound, tasksNotFound };
    }
    /**
     * Runs the task specified by the taskName parameter.
     *
     * @method runTask
     * @param {TaskName} taskName
     * @returns {Promise<[Result[], TaskError[]]>}
     * @memberof TaskList
     */
    async runTask(taskName) {
        let result;
        let task = this.find(taskName);
        if (task === undefined) {
            throw new Error(`The ${taskName} task was not found`);
        }
        this.debug('start %s run', task.fullyQualifiedTaskName);
        try {
            result = await this._runTask(task);
        }
        catch (error) {
            this.addError(task.fullyQualifiedTaskName, error);
        }
        this.debug('%s run done', task.fullyQualifiedTaskName);
        return [result, this._errors];
    }
    /**
     * Runs all tasks that have been added to the task list.
     *
     * @method runTasks
     * @returns {Promise<[Result[], TaskError[]]>}
     * @memberof TaskList
     */
    async runTasks(tasks) {
        let results = await this.eachTask(async (task) => {
            let result;
            this.debug('start %s run', task.fullyQualifiedTaskName);
            try {
                result = await this._runTask(task);
            }
            catch (error) {
                this.addError(task.fullyQualifiedTaskName, error);
            }
            this.debug('%s run done', task.fullyQualifiedTaskName);
            return result;
        }, tasks);
        return [results.flat().filter(Boolean).sort(task_result_comparator_1.taskResultComparator), this._errors];
    }
    async _runTask(task) {
        let t = process.hrtime();
        let result = await task.run();
        t = process.hrtime(t);
        this._timings[task.fullyQualifiedTaskName] = convertHrtime(t).seconds;
        return result;
    }
    /**
     * Gets a taskTypeMap from the type map
     *
     * @private
     * @method getByCategory
     * @param category
     */
    getByCategory(category) {
        if (!this._categories.has(category)) {
            this._categories.set(category, new Map());
        }
        return this._categories.get(category);
    }
    /**
     * Runs each task in parallel
     *
     * @private
     * @method eachTask
     * @param fn {Function} the function expressing the wrapped task to run
     * @returns {Promise<Result[][]>}
     */
    eachTask(fn, tasksToRun) {
        let availableTasks = tasksToRun || this.getTasks();
        return pMap(availableTasks.filter((task) => task.enabled), fn);
    }
    /**
     * Gets all tasks from all taskTypeMaps
     *
     * @private
     * @method getTasks
     */
    getTasks() {
        let values = [];
        this._categories.forEach((category) => {
            values = [...values, ...category.values()];
        });
        return values;
    }
    addError(taskName, error) {
        this._errors.push({ taskName, error });
    }
}
exports.default = TaskList;
//# sourceMappingURL=task-list.js.map